---
alwaysApply: false
---
# README Content Generation Rules

## Auto-update README Content

When the README.md file is modified or when the project structure changes, automatically update the README.md file with a comprehensive structure that includes:

1. A description section with component type and purpose
2. Data Model section (for microservices/backend services)
3. Async Messaging section (for microservices/backend services)
4. Configuration section (for all code repositories)
5. Standard project setup and deployment sections

## README Structure Template

The README should follow this structure:

```markdown
# [Project Name]

[Optional: Project logo or banner]

## Description

[Component Type]: [Brief description of what the component does]

[Detailed description of the component's purpose, functionality, and role in the system]

[Additional context about the component's responsibilities and key features]

## Data Model

[Only for microservices and backend services - follows readme-data-model.mdc rules]

## Async Messaging

[Only for microservices and backend services - follows readme-async-messaging.mdc rules]

## Configuration

[For all code repositories - follows readme-config.mdc rules]
```

## Component Type Detection

The system should automatically detect the component type based on project structure and dependencies:

### Microservice/Backend Service Indicators:
- NestJS framework (`@nestjs/core` in package.json)
- Database entities in `src/domain/models/`
- Configuration files in `src/config/`
- AMQP/RabbitMQ configuration
- Database migrations
- API controllers

### Web Application Indicators:
- Frontend frameworks (React, Vue, Angular, etc.)
- Build tools (Webpack, Vite, etc.)
- Static assets directories
- Browser-specific dependencies

### Library/Package Indicators:
- Library-specific package.json structure
- TypeScript declaration files
- Minimal runtime dependencies
- Export/import focused structure

## Description Generation Rules

### For Microservices/Backend Services:
```markdown
**Microservice**: [Service name and primary responsibility]

[Detailed description including:]
- Primary business function
- Key responsibilities
- Integration points with other services
- Data processing capabilities
- API endpoints or message handling
```

### For Web Applications:
```markdown
**Web Application**: [Application name and purpose]

[Detailed description including:]
- User-facing functionality
- Key features and capabilities
- Target user base
- Technology stack
- Deployment considerations
```

### For Libraries/Packages:
```markdown
**Library**: [Package name and functionality]

[Detailed description including:]
- Core functionality provided
- Target use cases
- API surface
- Integration requirements
- Version compatibility
```

## Section Inclusion Rules

### Data Model Section
- **Include when**: Component type is "Microservice" or "Backend Service"
- **Trigger**: Files in `src/domain/models/` are modified
- **Content**: Follows readme-data-model.mdc rules

### Async Messaging Section
- **Include when**: Component type is "Microservice" or "Backend Service" AND RabbitMQ configuration exists
- **Trigger**: Files in `src/config/` are modified
- **Content**: Follows readme-async-messaging.mdc rules

### Configuration Section
- **Include when**: All component types (Microservice, Backend Service, Web Application, Library)
- **Trigger**: Configuration files are modified (e.g., `src/config/`, `.env`, `package.json`, etc.)
- **Content**: Follows readme-config.mdc rules

### Standard Sections
- **Always include**: Description

## Update Triggers

The README should be updated when:

1. **README.md is directly modified** - Regenerate entire structure
2. **Package.json changes** - Update component type detection and dependencies
3. **Domain models change** - Update Data Model section
4. **Configuration changes** - Update Async Messaging and Configuration sections
5. **New major features added** - Update description and relevant sections

## Implementation Notes

- Use TypeScript AST parsing to analyze project structure
- Extract component type from package.json and file structure
- Generate appropriate description based on detected component type
- Maintain existing content when possible, only updating relevant sections
- Ensure Mermaid diagrams are properly formatted and valid
- Preserve custom content while standardizing structure
- Handle edge cases gracefully (missing files, malformed configurations, etc.)

## Content Preservation

- Always preserve existing custom content in sections
- Only replace auto-generated sections (Data Model, Async Messaging, Configuration)
- Maintain user-added sections and custom descriptions
- Preserve formatting and styling preferences
- Keep project-specific information intact
